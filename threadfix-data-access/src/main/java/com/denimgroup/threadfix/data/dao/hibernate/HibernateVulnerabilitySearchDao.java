////////////////////////////////////////////////////////////////////////
//
//     Copyright (c) 2009-2015 Denim Group, Ltd.
//
//     The contents of this file are subject to the Mozilla Public License
//     Version 2.0 (the "License"); you may not use this file except in
//     compliance with the License. You may obtain a copy of the License at
//     http://www.mozilla.org/MPL/
//
//     Software distributed under the License is distributed on an "AS IS"
//     basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
//     License for the specific language governing rights and limitations
//     under the License.
//
//     The Original Code is ThreadFix.
//
//     The Initial Developer of the Original Code is Denim Group, Ltd.
//     Portions created by Denim Group, Ltd. are Copyright (C)
//     Denim Group, Ltd. All Rights Reserved.
//
//     Contributor(s): Denim Group, Ltd.
//
////////////////////////////////////////////////////////////////////////
package com.denimgroup.threadfix.data.dao.hibernate;

import com.denimgroup.threadfix.data.dao.VulnerabilitySearchDao;
import com.denimgroup.threadfix.data.entities.Vulnerability;
import com.denimgroup.threadfix.data.entities.VulnerabilitySearchParameters;
import com.denimgroup.threadfix.data.entities.VulnerabilityTreeElement;
import org.hibernate.Criteria;
import org.hibernate.SessionFactory;
import org.hibernate.criterion.Order;
import org.hibernate.criterion.Projections;
import org.hibernate.transform.Transformers;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Repository;

import java.util.Date;
import java.util.List;

/**
 * Created by mac on 5/7/14.
 */
@Repository
@SuppressWarnings("unchecked")
public class HibernateVulnerabilitySearchDao implements VulnerabilitySearchDao {

    @Autowired
    private SessionFactory sessionFactory;

    private Criteria performLookupSetup(VulnerabilitySearchParameters parameters) {
        assert parameters != null;

        Criteria criteria = VulnerabilitySearchCriteriaConstructor.
                getCriteriaWithRestrictions(sessionFactory.getCurrentSession(), parameters);

        if (parameters.getNumberVulnerabilities() != null) {
            criteria.setMaxResults(parameters.getNumberVulnerabilities());
            if (parameters.getPage() != null)
                criteria.setFirstResult(parameters.getNumberVulnerabilities() * (parameters.getPage() - 1));
        }

        return criteria;
    }

    private void addOrders(VulnerabilitySearchParameters parameters, Criteria criteria) {
        for (String desc : parameters.getDescList()) {
            criteria.addOrder(Order.desc(desc));
        }
        if (parameters.getAscList() == null || parameters.getAscList().size() == 0)
            criteria.addOrder(Order.asc("surface.path"));
        else for (String asc: parameters.getAscList()) {
            criteria.addOrder(Order.asc(asc));
        }
    }

    @Override
    public List<Vulnerability> performLookup(VulnerabilitySearchParameters parameters) {
        assert parameters != null;

        Criteria criteria = performLookupSetup(parameters);

        // this is in this method and not the setup because it doesn't play nice with count
        addOrders(parameters, criteria);

        return (List<Vulnerability>) criteria.list();
    }

    @Override
    public long performLookupCount(VulnerabilitySearchParameters parameters) {
        assert parameters != null;

        Criteria criteria = performLookupSetup(parameters);

        Number numVulns = (Number) criteria.setProjection(Projections.rowCount()).uniqueResult();
        return numVulns.longValue();
    }

    @Override
    public List<VulnerabilityTreeElement> getTree(VulnerabilitySearchParameters parameters) {
        assert parameters != null;

        Criteria criteria = VulnerabilitySearchCriteriaConstructor.
                getCriteriaWithRestrictions(sessionFactory.getCurrentSession(), parameters);

        criteria.setProjection(Projections.projectionList()
                .add(Projections.countDistinct("id"), "numResults")
                .add(Projections.groupProperty("severity.intValue"))
                .add(Projections.groupProperty("genericVulnAlias.id"), "genericVulnerabilityId")
                .add(Projections.groupProperty("genericVulnAlias.name"), "genericVulnerabilityName")
                .add(Projections.groupProperty("genericVulnAlias.cweId"), "genericVulnerabilityDisplayId")
                .add(Projections.groupProperty("severity.intValue"), "severityIntValue")
        )
                .addOrder(Order.desc("severityIntValue"))
                .addOrder(Order.desc("numResults"));

        criteria.setResultTransformer(Transformers.aliasToBean(VulnerabilityTreeElement.class));

        return (List<VulnerabilityTreeElement>) criteria.list();
    }

    @Override
    public List<Object> getAges(VulnerabilitySearchParameters parameters) {
        assert parameters != null;

        List<Integer> idList = getVulnIdList(parameters);

        List<Object> result = sessionFactory.getCurrentSession()
                .createQuery("select new map( avg((day(:current_timestamp) + year(:current_timestamp) * 365) -( day(vuln.openTime) + year(vuln.openTime) * 365)) " +
                        "as datediff, vuln.genericSeverity.intValue as severity, vuln.genericSeverity.customName as severityCustomName, " +
                        "vuln.genericSeverity.name as severityName )" +
                        " from Vulnerability vuln where vuln.id in (:idList) group by vuln.genericSeverity.intValue")
                .setDate("current_timestamp", new Date())
                .setParameterList("idList", idList)
                .list();

        return result;
    }

    @Override
    public List<Object> getProgressByType(VulnerabilitySearchParameters parameters) {
        assert parameters != null;

        List<Integer> idList = getVulnIdList(parameters);

        List<Object> result = sessionFactory.getCurrentSession()
                .createQuery("select new map( avg((day(:current_timestamp) + year(:current_timestamp) * 365) -( day(vuln.openTime) + year(vuln.openTime) * 365)) " +
                        "as datediff, vuln.genericSeverity.intValue as severity, vuln.genericSeverity.customName as severityCustomName, " +
                        "vuln.genericSeverity.name as severityName )" +
                        " from Vulnerability vuln where vuln.id in (:idList) group by vuln.genericSeverity.intValue")
                .setDate("current_timestamp", new Date())
                .setParameterList("idList", idList)
                .list();

        return result;
    }

    private List<Integer> getVulnIdList(VulnerabilitySearchParameters parameters) {
        Criteria criteria = VulnerabilitySearchCriteriaConstructor.
                getCriteriaWithRestrictions(sessionFactory.getCurrentSession(), parameters);

        criteria.setProjection(Projections.projectionList()
                .add(Projections.property("id"))
        );

        List<Integer> idList = (List<Integer>) criteria.list();
        return idList;
    }

    @Override
    public Long getCount(VulnerabilitySearchParameters parameters) {
        return (Long) VulnerabilitySearchCriteriaConstructor.getCriteriaWithRestrictions(sessionFactory.getCurrentSession(), parameters)
                .setProjection(Projections.rowCount())
                .uniqueResult();
    }

}
