////////////////////////////////////////////////////////////////////////
//
//     Copyright (c) 2009-2013 Denim Group, Ltd.
//
//     The contents of this file are subject to the Mozilla Public License
//     Version 2.0 (the "License"); you may not use this file except in
//     compliance with the License. You may obtain a copy of the License at
//     http://www.mozilla.org/MPL/
//
//     Software distributed under the License is distributed on an "AS IS"
//     basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
//     License for the specific language governing rights and limitations
//     under the License.
//
//     The Original Code is ThreadFix.
//
//     The Initial Developer of the Original Code is Denim Group, Ltd.
//     Portions created by Denim Group, Ltd. are Copyright (C)
//     Denim Group, Ltd. All Rights Reserved.
//
//     Contributor(s): Denim Group, Ltd.
//
////////////////////////////////////////////////////////////////////////
package com.denimgroup.threadfix.service;

import java.io.BufferedReader;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.net.URISyntaxException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Enumeration;
import java.util.List;
import java.util.zip.ZipEntry;
import java.util.zip.ZipFile;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import com.denimgroup.threadfix.data.dao.ChannelTypeDao;
import com.denimgroup.threadfix.data.dao.ChannelVulnerabilityDao;
import com.denimgroup.threadfix.data.dao.GenericVulnerabilityDao;
import com.denimgroup.threadfix.data.entities.ChannelType;
import com.denimgroup.threadfix.data.entities.ChannelVulnerability;
import com.denimgroup.threadfix.data.entities.GenericVulnerability;
import com.denimgroup.threadfix.data.entities.ScannerType;
import com.denimgroup.threadfix.data.entities.VulnerabilityMap;

@Service
@Transactional(readOnly = true)
public class ChannelVulnerabilityServiceImpl implements ChannelVulnerabilityService{
	private final SanitizedLogger log = new SanitizedLogger(ChannelVulnerabilityServiceImpl.class);
	private ChannelVulnerabilityDao channelVulnerabilityDao;
	private GenericVulnerabilityDao genericVulnerabilityDao;
	private ChannelTypeDao channelTypeDao;
	
	@Autowired
	public ChannelVulnerabilityServiceImpl(ChannelVulnerabilityDao channelVulnerabilityDao,
			ChannelTypeDao channelTypeDao,
			GenericVulnerabilityDao genericVulnerabilityDao) {
		this.channelVulnerabilityDao = channelVulnerabilityDao;
		this.genericVulnerabilityDao = genericVulnerabilityDao;
		this.channelTypeDao = channelTypeDao;
	}
	
	@Override
	public List<ChannelVulnerability> loadSuggested(String prefix) { 
		return channelVulnerabilityDao.retrieveSuggested(prefix);
	}

	@Override
	public boolean isValidManualName(String code) {
		return channelVulnerabilityDao.isValidManualName(code);
	}

	@Override
	public List<ChannelVulnerability> loadAllManual() {
		return channelVulnerabilityDao.retrieveAllManual();
	}
	
	/**
	 * Add/Update ChannelVulnebilities and their VulnerabilityMaps from reading csv file.
	 * @return 
	 * @throws IOException 
	 * @throws URISyntaxException 
	 */
	@Override
	public List<String[]> updateChannelVulnerability() throws IOException, URISyntaxException {
		BufferedReader br = null; 
		String line = "";
		String cvsSplitBy = ",";
		InputStream zis = null;
		List<String[]> resultList = new ArrayList<String[]>();
		try {
			File file = new File(ChannelVulnerabilityServiceImpl.class.getClassLoader().getResource("scanners.jar").toURI());
			ZipFile zipFile = new ZipFile(file.getAbsolutePath());
			
			for (ScannerType type: ScannerType.values()) {
				
				ChannelType channelType = channelTypeDao.retrieveByName(type.getFullName());
				if (channelType == null) {
					log.warn("Unable to find ChannelType for type name: " + type.getFullName());
					break;
				}
				zis = null;
				zis = searchCsvFile(type.getShortName()+".csv", zipFile);
				if (zis != null) {
					br = new BufferedReader(new InputStreamReader(zis, "UTF-8"));

					int numUpdated = 0;
					while ((line = br.readLine()) != null) {

						// use comma as separator
						String[] elements = line.split(cvsSplitBy);
						String cvName = elements[0];
						String cvCode = elements[1];
						String genericId = elements[2];
						ChannelVulnerability cv = channelVulnerabilityDao.retrieveByCode(channelType, cvCode);

						try {
							GenericVulnerability gv = genericVulnerabilityDao.retrieveById(Integer.valueOf(genericId));
							if (gv == null) {
								log.warn("Unable to find Generic Vulnerability for GenericId " + genericId);
								break;
							}
							if (cv != null) {
								// Update
								boolean isDifferent = false;
								if (!cv.getName().equalsIgnoreCase(cvName)) {
									cv.setName(cvName);
									isDifferent = true;
								}
								if (cv.getGenericVulnerability() == null || cv.getGenericVulnerability().getId() != gv.getId()) {
									
									if (cv.getGenericVulnerability() != null) {
										for (VulnerabilityMap map: cv.getVulnerabilityMaps()) {
											map.setChannelVulnerability(null);
										}
									}
									
									VulnerabilityMap map = new VulnerabilityMap();
									map.setMappable(true);
									map.setChannelVulnerability(cv);
									map.setGenericVulnerability(gv);
									cv.setVulnerabilityMaps(Arrays.asList(map));
									isDifferent = true;
								}
								if (isDifferent) {
									channelVulnerabilityDao.saveOrUpdate(cv);
									numUpdated++;
								}
							} else {
								// Create new
								cv = new ChannelVulnerability();
								cv.setCode(cvCode);
								cv.setName(cvName);
								cv.setChannelType(channelType);

								VulnerabilityMap map = new VulnerabilityMap();
								map.setMappable(true);
								map.setChannelVulnerability(cv);
								map.setGenericVulnerability(gv);
								cv.setVulnerabilityMaps(Arrays.asList(map));
								channelVulnerabilityDao.saveOrUpdate(cv);
								numUpdated++;
							}
						} catch (NumberFormatException e) {
							log.warn("genericId " + genericId + " is not a number");
						}
					}
					if (numUpdated > 0) {
						String[] result = new String[]{type.getFullName(), String.valueOf(numUpdated)};
						resultList.add(result);
					}
					log.info("Updated " + numUpdated + " Channel Vulnerabilities for Channel Type " + type.getFullName());
				}
			}
		} catch (URISyntaxException e) {
			log.error("Error when trying to read scanners.jar");
			throw e;	
		} catch (IOException e) {
			log.error("Error when trying to read file from scanners.jar");
			throw e;
		} finally {
			if (br != null) {
				try {
					br.close();
				} catch (IOException e) {
					e.printStackTrace();
				}
			}
			if (zis != null) {
				try {
					zis.close();
				} catch (IOException e) {
					e.printStackTrace();
				}
			}
		}
		return resultList;
		
	}

	private InputStream searchCsvFile(String name, ZipFile zipFile) throws IOException {
		Enumeration<? extends ZipEntry> entries = zipFile.entries();
		while (entries.hasMoreElements()) {
			ZipEntry e = entries.nextElement();
			if (e.getName().endsWith(name))
				return zipFile.getInputStream(e);
		}
		return null;
	}
}
