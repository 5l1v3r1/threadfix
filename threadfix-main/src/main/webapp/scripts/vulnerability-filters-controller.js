var threadfixModule = angular.module('threadfix');

threadfixModule.controller("VulnerabilityFiltersController", function($modal, $scope, $http, $log) {

    var nameCompare = function(a,b) {
        return a.sourceGenericVulnerability.name.localeCompare(b.sourceGenericVulnerability.name);
    };

    var toStrings = function(severityFilter) {
        for (var key in severityFilter) {
            if (severityFilter.hasOwnProperty(key) && key.toString().substring(0,4) === "show") { // to make IntelliJ happy
                if (severityFilter[key] === true) {
                    severityFilter[key] = "true";
                }

                if (severityFilter[key] === false) {
                    severityFilter[key] = "false";
                }
            }
        }

        return severityFilter;
    }

    var toBooleans = function(severityFilter) {
        for (var key in severityFilter) {
            if (severityFilter.hasOwnProperty(key) && key.toString().substring(0,4) === "show") { // to make IntelliJ happy
                if (severityFilter[key] === "true") {
                    severityFilter[key] = true;
                }

                if (severityFilter[key] === "false") {
                    severityFilter[key] = false;
                }
            }
        }

        return severityFilter;
    }

    $scope.$watch('csrfToken', function(){
        $http.get('filters/map' + $scope.csrfToken).
            success(function(data, status, headers, config) {

                if (data.success) {

                    $scope.vulnerabilityFilter = data.object.vulnerabilityFilter;
                    $scope.severityFilter = toStrings(data.object.severityFilter);
                    $scope.vulnerabilityFilterList = data.object.vulnerabilityFilterList;
                    $scope.vulnerabilityFilterList.sort(nameCompare);
                    if ($scope.vulnerabilityFilterList.length > 0) {
                        $scope.currentVulnFilters = $scope.vulnerabilityFilterList;
                    }
                    $scope.type = data.object.type;
                    $scope.genericSeverities = data.object.genericSeverities;
                    $scope.genericVulnerabilities = data.object.genericVulnerabilities;

                    $scope.setTab(data.object.type);
                } else {
                    $scope.errorMessage = "Failure. Message was : " + data.message;
                }

                $scope.initialized = true;
            }).
            error(function(data, status, headers, config) {
                $scope.initialized = true;
                $scope.errorMessage = "Failed to retrieve map. HTTP status was " + status;
            });
    });

    $scope.setTab = function(tab) {
        $scope.tab = tab;

        if (tab === 'Global') {
            $scope.vulnFiltersTitle = 'Global Vulnerability Filters';
            $scope.severityFiltersTitle = 'Global Severity Filters';
        } else if (tab === 'Application') {
            $scope.vulnFiltersTitle = 'Application Vulnerability Filters';
            $scope.severityFiltersTitle = 'Application Severity Filters';
        } else {
            $scope.severityFiltersTitle = 'Team Severity Filters';
            $scope.vulnFiltersTitle = 'Team Vulnerability Filters';
        }
    }

    $scope.showNewFilterModal = function() {
        var modalInstance = $modal.open({
            windowClass: 'filter-modal',
            templateUrl: 'vulnerabilityFilterForm.html',
            controller: 'ModalControllerWithConfig',
            resolve: {
                url: function() {
                    return "filters/new" + $scope.csrfToken;
                },
                object: function () {
                    return {
                        targetGenericSeverity: {
                            id: 5
                        }
                    }
                },
                config: function() {
                    return {
                        showDelete: false,
                        title: 'New Filter',
                        genericVulnerabilities: $scope.genericVulnerabilities,
                        genericSeverities: $scope.genericSeverities
                    }
                },
                buttonText: function() {
                    return "Create Filter";
                }
            }
        });

        modalInstance.result.then(function (newApplication) {

            if (!$scope.currentVulnFilters) {
                $scope.currentVulnFilters = [];
            }

            $scope.currentVulnFilters.push(newApplication);

            $scope.currentVulnFilters.sort(nameCompare);

            $scope.successMessage = "Successfully added application " + newApplication.name;

        }, function () {
            $log.info('Modal dismissed at: ' + new Date());
        });
    }

    $scope.editFilter = function(filter) {
        var modalInstance = $modal.open({
            windowClass: 'filter-modal',
            templateUrl: 'vulnerabilityFilterForm.html',
            controller: 'ModalControllerWithConfig',
            resolve: {
                url: function() {
                    return "filters/" + filter.id + "/edit" + $scope.csrfToken;
                },
                object: function () {
                    return filter;
                },
                config: function() {
                    return {
                        showDelete: true,
                        title: 'Edit Filter',
                        genericVulnerabilities: $scope.genericVulnerabilities,
                        genericSeverities: $scope.genericSeverities
                    }
                },
                buttonText: function() {
                    return "Save Changes";
                },
                deleteUrl: function() {
                    return "filters/" + filter.id + "/delete" + $scope.csrfToken;
                }
            }
        });

        modalInstance.result.then(function (newFilter) {

            if (newFilter) {
                filter.targetGenericSeverity = newFilter.targetGenericSeverity;
                filter.sourceGenericVulnerability = newFilter.sourceGenericVulnerability;
                $scope.successMessage = "Successfully edited filter " + newFilter.id;
            } else {
                var index = $scope.currentVulnFilters.indexOf(filter);

                if (index > -1) {
                    $scope.currentVulnFilters.splice(index, 1);
                }

                if ($scope.currentVulnFilters.length === 0) {
                    $scope.currentVulnFilters = undefined;
                }
            }
        }, function () {
            $log.info('Modal dismissed at: ' + new Date());
        });
    }

    $scope.submitSeverityFilterForm = function() {
        $scope.submittingSeverityFilter = true;

        $scope.severitySuccessMessage = undefined;
        $scope.severityErrorMessage = undefined;

        $http.post('/configuration/severityFilter/set' + $scope.csrfToken, toBooleans($scope.severityFilter)).
            success(function(data, status, headers, config) {

                if (data.success) {
                    $scope.severitySuccessMessage = "Successfully saved filter settings.";
                } else {
                    $scope.severityErrorMessage = "Failure. Message was : " + data.message;
                }

                $scope.submittingSeverityFilter = false;
            }).
            error(function(data, status, headers, config) {
                $scope.submittingSeverityFilter = false;
                $scope.severityErrorMessage = "Failed to retrieve map. HTTP status was " + status;
            });

        toStrings($scope.severityFilter);
    }

});